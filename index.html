<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤§å­¦ç”Ÿå¿ƒç†åˆ†ææ•°å­—äººä»£ç† - å¸¦è¡¨æƒ…è¯†åˆ«</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 32px;
            color: #4a90e2;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 16px;
            color: #666;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .left-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .right-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .panel-title {
            font-size: 20px;
            color: #4a90e2;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        
        #scene-container {
            width: 100%;
            height: 300px;
            background: #f5f5f5;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        #camera-preview {
            width: 100%;
            height: 250px;
            background: #333;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .camera-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #4a90e2;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: #3a80d2;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .emotion-display {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .emotion-result {
            font-size: 24px;
            text-align: center;
            margin: 10px 0;
        }
        
        .chat-container {
            margin-bottom: 30px;
        }
        
        .response-bubble {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .input-container {
            display: flex;
            gap: 10px;
        }
        
        #user-input {
            flex: 1;
            padding: 15px;
            border: 2px solid #4a90e2;
            border-radius: 10px;
            font-size: 16px;
            outline: none;
        }
        
        #submit-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #4a90e2 0%, #357ae8 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #submit-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }
        
        #submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .header h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>å¤§å­¦ç”Ÿå¿ƒç†åˆ†ææ•°å­—äººä»£ç† - å¸¦è¡¨æƒ…è¯†åˆ«</h1>
            <p>AIæ•°å­—äººç»“åˆè¡¨æƒ…åˆ†æï¼Œæä¾›æ›´ç²¾å‡†çš„å¿ƒç†çŠ¶æ€è¯„ä¼°</p>
        </div>
        
        <div class="status-indicator">
            <div class="status-dot"></div>
            <span id="status-text">ç³»ç»Ÿå°±ç»ª</span>
        </div>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="panel-title">æ•°å­—äººäº¤äº’</div>
                <div id="scene-container">
                    <!-- 3Dåœºæ™¯å°†åœ¨è¿™é‡Œæ¸²æŸ“ -->
                </div>
                
                <div class="input-container">
                    <input type="text" id="user-input" placeholder="è¯·æè¿°ä½ å½“å‰çš„å¿ƒç†çŠ¶æ€æˆ–é‡åˆ°çš„é—®é¢˜...">
                    <button id="submit-btn" class="btn">å‘é€</button>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="panel-title">è¡¨æƒ…åˆ†æ</div>
                <video id="camera-preview" autoplay playsinline style="display: none;"></video>
                
                <div class="camera-controls">
                    <button id="camera-toggle" class="btn">å¼€å¯æ‘„åƒå¤´</button>
                    <button id="emotion-toggle" class="btn" disabled>å¼€å¯è¡¨æƒ…åˆ†æ</button>
                </div>
                
                <div class="emotion-display" style="display: none;">
                    <div class="panel-title">å½“å‰æƒ…ç»ªåˆ†æ</div>
                    <div class="emotion-result" id="emotion-result">ç­‰å¾…åˆ†æ...</div>
                    <div id="emotion-bars"></div>
                </div>
            </div>
        </div>
        
        <div class="chat-container">
            <div class="panel-title">å¿ƒç†åˆ†æç»“æœ</div>
            <div class="response-bubble" id="response-content">
                åœ¨è¿™é‡Œæ˜¾ç¤ºå¿ƒç†åˆ†æç»“æœ...
            </div>
        </div>
    </div>

    <script>
        // æƒ…ç»ªæ˜ å°„
        const emotionIcons = {
            'angry': 'ğŸ˜ ', 'disgust': 'ğŸ¤¢', 'fear': 'ğŸ˜¨',
            'happy': 'ğŸ˜Š', 'sad': 'ğŸ˜¢', 'surprise': 'ğŸ˜²', 'neutral': 'ğŸ˜'
        };
        
        const emotionDescriptions = {
            'angry': 'ç”Ÿæ°”', 'disgust': 'åŒæ¶', 'fear': 'ææƒ§',
            'happy': 'å¼€å¿ƒ', 'sad': 'æ‚²ä¼¤', 'surprise': 'æƒŠè®¶', 'neutral': 'å¹³é™'
        };
        
        const emotionColors = {
            'angry': '#ff6b6b',
            'disgust': '#9b59b6',
            'fear': '#f39c12',
            'happy': '#2ecc71',
            'sad': '#3498db',
            'surprise': '#9b59b6',
            'neutral': '#95a5a6'
        };
        
        // çŠ¶æ€å˜é‡
        let isAnalyzing = false;
        let cameraActive = false;
        let emotionAnalysisActive = false;
        let videoStream = null;
        let emotionInterval = null;
        let currentEmotion = 'neutral';
        let currentEmotionScores = {};
        
        // DOMå…ƒç´ 
        const statusText = document.getElementById('status-text');
        const userInput = document.getElementById('user-input');
        const submitBtn = document.getElementById('submit-btn');
        const responseContent = document.getElementById('response-content');
        const cameraPreview = document.getElementById('camera-preview');
        const cameraToggle = document.getElementById('camera-toggle');
        const emotionToggle = document.getElementById('emotion-toggle');
        const emotionDisplay = document.querySelector('.emotion-display');
        const emotionResult = document.getElementById('emotion-result');
        const emotionBars = document.getElementById('emotion-bars');
        const sceneContainer = document.getElementById('scene-container');
        
        // APIåŸºç¡€URL
        const API_BASE_URL = 'http://localhost:5000/api';
        
        // ==================== 3Dæ•°å­—äººéƒ¨åˆ† ====================
        
        // åˆ›å»ºä¼˜åŒ–åçš„é›ªäººå½¢è±¡
        function createSnowmanCharacter() {
            // åˆ›å»ºåœºæ™¯
            const scene = new THREE.Scene();
            scene.background = null;
            
            // åˆ›å»ºç›¸æœº
            const camera = new THREE.PerspectiveCamera(45, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            sceneContainer.appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0xb3e0ff, 0.4);
            fillLight.position.set(-5, 5, 5);
            scene.add(fillLight);
            
            // åˆ›å»ºé›ªäººç»„
            const snowman = new THREE.Group();
            
            // åˆ›å»ºé›ªäººèº«ä½“
            const bottomBodyGeometry = new THREE.SphereGeometry(1.0, 32, 32);
            const headGeometry = new THREE.SphereGeometry(0.7, 32, 32);
            
            const snowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf8f8f8,
                shininess: 30,
                transparent: true,
                opacity: 0.95
            });
            
            const bottomBody = new THREE.Mesh(bottomBodyGeometry, snowMaterial);
            bottomBody.position.y = -0.3;
            bottomBody.castShadow = true;
            snowman.add(bottomBody);
            
            const head = new THREE.Mesh(headGeometry, snowMaterial);
            head.position.y = 0.9;
            head.castShadow = true;
            head.scale.set(1, 1.1, 1);
            snowman.add(head);
            
            // åˆ›å»ºçœ¼ç›
            const eyeGroup = new THREE.Group();
            
            const eyeWhiteGeometry = new THREE.SphereGeometry(0.18, 16, 16);
            const eyeWhiteMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            
            const leftEyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
            leftEyeWhite.position.set(-0.25, 1.0, 0.55);
            eyeGroup.add(leftEyeWhite);
            
            const rightEyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
            rightEyeWhite.position.set(0.25, 1.0, 0.55);
            eyeGroup.add(rightEyeWhite);
            
            const pupilGeometry = new THREE.SphereGeometry(0.1, 12, 12);
            const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
            
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.25, 1.0, 0.7);
            eyeGroup.add(leftPupil);
            
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.25, 1.0, 0.7);
            eyeGroup.add(rightPupil);
            
            snowman.add(eyeGroup);
            
            // é¼»å­
            const noseGeometry = new THREE.SphereGeometry(0.05, 12, 12);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xffa8b5 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 0.95, 0.6);
            snowman.add(nose);
            
            // å˜´å·´
            const mouthGeometry = new THREE.TorusGeometry(0.15, 0.02, 8, 32, Math.PI);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b7a });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 0.8, 0.6);
            mouth.rotation.x = Math.PI / 2;
            snowman.add(mouth);
            
            // è…®çº¢
            const blushGeometry = new THREE.SphereGeometry(0.12, 12, 12);
            const blushMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff9eb5,
                transparent: true,
                opacity: 0.7
            });
            
            const leftBlush = new THREE.Mesh(blushGeometry, blushMaterial);
            leftBlush.position.set(-0.45, 0.95, 0.5);
            snowman.add(leftBlush);
            
            const rightBlush = new THREE.Mesh(blushGeometry, blushMaterial);
            rightBlush.position.set(0.45, 0.95, 0.5);
            snowman.add(rightBlush);
            
            snowman.position.set(0, 0, 0);
            scene.add(snowman);
            
            // æ·»åŠ åŠ¨ç”»
            let animationTime = 0;
            let blinkTimer = 0;
            let isBlinking = false;
            
            function animate() {
                requestAnimationFrame(animate);
                
                animationTime += 0.015;
                blinkTimer += 0.05;
                
                // å‘¼å¸æ•ˆæœ
                const breath = Math.sin(animationTime * 1.5) * 0.02 + 1;
                snowman.scale.set(breath, breath, breath);
                
                // æµ®åŠ¨æ•ˆæœ
                snowman.position.y = Math.sin(animationTime) * 0.1;
                
                // åŸºç¡€æ—‹è½¬
                snowman.rotation.y = animationTime * 0.05;
                
                // éšæœºçœ¨çœ¼
                if (!isBlinking && blinkTimer > 10 + Math.random() * 20) {
                    isBlinking = true;
                    blinkTimer = 0;
                }
                
                if (isBlinking) {
                    const blinkProgress = Math.min(blinkTimer * 10, 1);
                    const eyeScaleY = 1 - blinkProgress;
                    leftEyeWhite.scale.y = eyeScaleY;
                    rightEyeWhite.scale.y = eyeScaleY;
                    
                    if (blinkTimer > 0.2) {
                        isBlinking = false;
                        blinkTimer = 0;
                    }
                } else {
                    leftEyeWhite.scale.y = 1;
                    rightEyeWhite.scale.y = 1;
                }
                
                // æ ¹æ®å½“å‰æƒ…ç»ªè°ƒæ•´é›ªäººè¡¨æƒ…
                updateSnowmanByEmotion(snowman, currentEmotion);
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            });
            
            return { snowman };
        }
        
        // æ ¹æ®æƒ…ç»ªæ›´æ–°é›ªäººè¡¨æƒ…
        function updateSnowmanByEmotion(snowman, emotion) {
            if (!snowman.children || !snowman.children[1]) return;
            
            const head = snowman.children[1]; // å¤´éƒ¨
            
            switch(emotion) {
                case 'happy':
                    // å¾®ç¬‘
                    if (head.children && head.children[4]) {
                        head.children[4].position.y = 0.8; // å˜´å·´ä½ç½®
                        head.children[4].rotation.x = Math.PI / 2 - 0.1;
                    }
                    break;
                case 'sad':
                    // éš¾è¿‡
                    if (head.children && head.children[4]) {
                        head.children[4].position.y = 0.85;
                        head.children[4].rotation.x = Math.PI / 2 + 0.1;
                    }
                    break;
                default:
                    // ä¸­æ€§
                    if (head.children && head.children[4]) {
                        head.children[4].position.y = 0.8;
                        head.children[4].rotation.x = Math.PI / 2;
                    }
            }
        }
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // åˆ›å»º3Dé›ªäºº
            createSnowmanCharacter();
            
            // è¯¢é—®æ˜¯å¦å¼€å¯æ‘„åƒå¤´
            setTimeout(() => {
                if (confirm('æ˜¯å¦å¼€å¯æ‘„åƒå¤´è¿›è¡Œè¡¨æƒ…åˆ†æï¼Ÿ')) {
                    startCamera();
                }
            }, 1000);
            
            // ç»‘å®šäº‹ä»¶
            submitBtn.addEventListener('click', analyzeInput);
            userInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') analyzeInput();
            });
            
            cameraToggle.addEventListener('click', toggleCamera);
            emotionToggle.addEventListener('click', toggleEmotionAnalysis);
        });
        
        // æ‘„åƒå¤´æ§åˆ¶
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "user" }
                });
                
                videoStream = stream;
                cameraPreview.srcObject = stream;
                cameraPreview.style.display = 'block';
                cameraToggle.textContent = 'å…³é—­æ‘„åƒå¤´';
                cameraActive = true;
                
                emotionToggle.disabled = false;
                statusText.textContent = "æ‘„åƒå¤´å·²å¼€å¯";
            } catch (err) {
                console.error("æ‘„åƒå¤´é”™è¯¯:", err);
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´");
            }
        }
        
        function stopCamera() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            cameraPreview.srcObject = null;
            cameraPreview.style.display = 'none';
            cameraToggle.textContent = 'å¼€å¯æ‘„åƒå¤´';
            cameraActive = false;
            
            stopEmotionAnalysis();
            emotionToggle.textContent = 'å¼€å¯è¡¨æƒ…åˆ†æ';
            emotionToggle.disabled = true;
            emotionAnalysisActive = false;
            
            statusText.textContent = "ç³»ç»Ÿå°±ç»ª";
        }
        
        function toggleCamera() {
            if (cameraActive) {
                stopCamera();
            } else {
                startCamera();
            }
        }
        
        // è¡¨æƒ…åˆ†ææ§åˆ¶
        function startEmotionAnalysis() {
            if (!cameraActive) return;
            
            emotionAnalysisActive = true;
            emotionToggle.textContent = 'åœæ­¢è¡¨æƒ…åˆ†æ';
            emotionDisplay.style.display = 'block';
            statusText.textContent = "è¡¨æƒ…åˆ†æä¸­...";
            
            emotionInterval = setInterval(captureAndAnalyzeEmotion, 2000);
            captureAndAnalyzeEmotion();
        }
        
        function stopEmotionAnalysis() {
            emotionAnalysisActive = false;
            if (emotionInterval) {
                clearInterval(emotionInterval);
                emotionInterval = null;
            }
            emotionDisplay.style.display = 'none';
            statusText.textContent = "ç³»ç»Ÿå°±ç»ª";
        }
        
        function toggleEmotionAnalysis() {
            if (emotionAnalysisActive) {
                stopEmotionAnalysis();
            } else {
                startEmotionAnalysis();
            }
        }
        
        // æ•è·å’Œåˆ†æè¡¨æƒ…
        async function captureAndAnalyzeEmotion() {
            if (!cameraActive || !emotionAnalysisActive) return;
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 480;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(cameraPreview, 0, 0, canvas.width, canvas.height);
                
                const imageData = canvas.toDataURL('image/jpeg', 0.7);
                
                const response = await fetch(`${API_BASE_URL}/analyze_emotion`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: imageData })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentEmotion = result.dominant_emotion;
                    currentEmotionScores = result.emotion_scores || {};
                    updateEmotionDisplay();
                    statusText.textContent = `æ£€æµ‹åˆ°: ${emotionDescriptions[currentEmotion]}`;
                }
            } catch (error) {
                console.error('è¡¨æƒ…åˆ†æå¤±è´¥:', error);
            }
        }
        
        function updateEmotionDisplay() {
            emotionResult.textContent = `${emotionIcons[currentEmotion]} ${emotionDescriptions[currentEmotion]}`;
            
            // æ›´æ–°æƒ…ç»ªæ¡
            emotionBars.innerHTML = '';
            
            // æ’åºæƒ…ç»ªåˆ†æ•°
            const sortedEmotions = Object.entries(currentEmotionScores)
                .sort((a, b) => b[1] - a[1]);
            
            sortedEmotions.forEach(([emotion, score]) => {
                const barContainer = document.createElement('div');
                barContainer.style.margin = '5px 0';
                
                const label = document.createElement('div');
                label.style.display = 'flex';
                label.style.justifyContent = 'space-between';
                label.innerHTML = `<span>${emotionIcons[emotion] || 'ğŸ˜'} ${emotionDescriptions[emotion] || emotion}</span><span>${score.toFixed(1)}%</span>`;
                
                const bar = document.createElement('div');
                bar.style.height = '8px';
                bar.style.background = '#eee';
                bar.style.borderRadius = '4px';
                bar.style.overflow = 'hidden';
                
                const fill = document.createElement('div');
                fill.style.height = '100%';
                fill.style.width = `${score}%`;
                fill.style.background = emotionColors[emotion] || '#4a90e2';
                fill.style.transition = 'width 0.5s ease';
                
                bar.appendChild(fill);
                barContainer.appendChild(label);
                barContainer.appendChild(bar);
                emotionBars.appendChild(barContainer);
            });
        }
        
        // å¿ƒç†åˆ†æ
        async function analyzeInput() {
            const inputText = userInput.value.trim();
            if (inputText && !isAnalyzing) {
                isAnalyzing = true;
                statusText.textContent = "åˆ†æä¸­...";
                submitBtn.disabled = true;
                
                responseContent.innerHTML = `<div style="text-align: center; padding: 20px;">
                    <div style="width: 30px; height: 30px; border: 3px solid #f3f3f3; border-top: 3px solid #4a90e2; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                    <p>æ­£åœ¨åˆ†æä½ çš„å¿ƒç†çŠ¶æ€...</p>
                </div>`;
                
                try {
                    const payload = {
                        message: inputText,
                        detected_emotion: currentEmotion
                    };
                    
                    // é¦–å…ˆå°è¯•ä½¿ç”¨æœ¬åœ°æ¨¡å‹API
                    const localResponse = await fetch(`${API_BASE_URL}/analyze_local`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const localData = await localResponse.json();
                    
                    if (localData.success) {
                        // æœ¬åœ°æ¨¡å‹æˆåŠŸ
                        let formattedResponse = localData.response;
                        
                        // æ·»åŠ æ¨¡å‹æ¥æºæç¤º
                        formattedResponse += `<div style="margin-top: 20px; padding: 10px; background: rgba(46, 204, 113, 0.1); border-radius: 8px; font-size: 14px; color: #27ae60;">
                            <strong>ğŸ§  æœ¬åœ°å¿ƒç†å¤§æ¨¡å‹ç”Ÿæˆ</strong> | æƒ…ç»ªçŠ¶æ€: ${emotionDescriptions[currentEmotion]} ${emotionIcons[currentEmotion]}
                        </div>`;
                        
                        responseContent.innerHTML = formattedResponse;
                        statusText.textContent = "æœ¬åœ°æ¨¡å‹åˆ†æå®Œæˆ";
                    } else {
                        // æœ¬åœ°æ¨¡å‹å¤±è´¥ï¼Œä½¿ç”¨é€šç”¨API
                        console.log("æœ¬åœ°æ¨¡å‹ä¸å¯ç”¨ï¼Œä½¿ç”¨é€šç”¨API...");
                        await useGeneralAPI(payload);
                    }
                    
                } catch (error) {
                    console.error('APIè°ƒç”¨é”™è¯¯:', error);
                    responseContent.innerHTML = `<div style="color: #e74c3c;">
                        <p>åˆ†æå¤±è´¥: ${error.message}</p>
                        <p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•</p>
                    </div>`;
                    statusText.textContent = "åˆ†æå¤±è´¥";
                } finally {
                    isAnalyzing = false;
                    submitBtn.disabled = false;
                    userInput.value = '';
                    userInput.focus();
                }
            }
        }
        
        // é€šç”¨APIè°ƒç”¨å‡½æ•°
        async function useGeneralAPI(payload) {
            try {
                const response = await fetch(`${API_BASE_URL}/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    let formattedResponse = data.response;
                    
                    // æ ¹æ®æ¨¡å‹æ¥æºæ·»åŠ ä¸åŒçš„æç¤º
                    const modelSource = data.model_source || 'deepseek_api';
                    const sourceText = modelSource === 'local_psychology_model' ? 
                        'ğŸ§  æœ¬åœ°å¿ƒç†å¤§æ¨¡å‹' : 'ğŸ¤– DeepSeek AI';
                    
                    formattedResponse += `<div style="margin-top: 20px; padding: 10px; background: rgba(110, 203, 245, 0.1); border-radius: 8px; font-size: 14px; color: #3498db;">
                        <strong>${sourceText} ç”Ÿæˆ</strong> | æƒ…ç»ªçŠ¶æ€: ${emotionDescriptions[currentEmotion]} ${emotionIcons[currentEmotion]}
                    </div>`;
                    
                    responseContent.innerHTML = formattedResponse;
                    statusText.textContent = "åˆ†æå®Œæˆ";
                } else {
                    throw new Error(data.error || 'APIè¯·æ±‚å¤±è´¥');
                }
            } catch (error) {
                console.error('é€šç”¨APIè°ƒç”¨é”™è¯¯:', error);
                
                // å¦‚æœæ‰€æœ‰APIéƒ½å¤±è´¥ï¼Œæ˜¾ç¤ºå¤‡é€‰å›å¤
                const fallbackResponse = generateFallbackResponse(userInput.value, currentEmotion);
                responseContent.innerHTML = fallbackResponse + `<div style="margin-top: 20px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 14px; color: #666; text-align: center;">
                    âš ï¸ ç³»ç»Ÿæš‚æ—¶ä½¿ç”¨å¤‡é€‰å›å¤ï¼Œè¯·ç¨åé‡è¯•
                </div>`;
                statusText.textContent = "ä½¿ç”¨å¤‡é€‰å›å¤";
            }
        }
        
        // å¤‡é€‰å›å¤ç”Ÿæˆå‡½æ•°
        function generateFallbackResponse(userInput, emotion) {
            const emotionContext = {
                'happy': 'çœ‹èµ·æ¥æ‚¨å¿ƒæƒ…ä¸é”™',
                'sad': 'æ„Ÿå—åˆ°æ‚¨çš„ä½è½æƒ…ç»ª',
                'angry': 'ç†è§£æ‚¨çš„çƒ¦èº',
                'fear': 'æ„Ÿå—åˆ°æ‚¨çš„ç´§å¼ ',
                'neutral': ''
            }[emotion] || '';
            
            const keywordResponses = {
                'å‹åŠ›': `${emotionContext}ã€‚å¯¹äºå‹åŠ›é—®é¢˜ï¼Œå»ºè®®ï¼š<br>1. æ·±å‘¼å¸æ”¾æ¾ç»ƒä¹ <br>2. åˆç†å®‰æ’æ—¶é—´å’Œä¼˜å…ˆçº§<br>3. é€‚é‡è¿åŠ¨é‡Šæ”¾å‹åŠ›<br>4. ä¸æœ‹å‹æˆ–å®¶äººå€¾è¯‰`,
                'ç„¦è™‘': `${emotionContext}ã€‚åº”å¯¹ç„¦è™‘çš„æ–¹æ³•ï¼š<br>1. æ­£å¿µå†¥æƒ³ç»ƒä¹ <br>2. å†™ä¸‹æ‹…å¿§äº‹é¡¹<br>3. æ¸è¿›å¼è‚Œè‚‰æ”¾æ¾<br>4. ä¿æŒè§„å¾‹ä½œæ¯`,
                'å¤±çœ ': `${emotionContext}ã€‚æ”¹å–„ç¡çœ çš„å»ºè®®ï¼š<br>1. ç¡å‰1å°æ—¶ä¸ä½¿ç”¨ç”µå­è®¾å¤‡<br>2. åˆ›é€ èˆ’é€‚çš„ç¡çœ ç¯å¢ƒ<br>3. ä¿æŒè§„å¾‹çš„ä½œæ¯æ—¶é—´<br>4. é¿å…ç¡å‰æ‘„å…¥å’–å•¡å› `,
                'æƒ…ç»ª': `${emotionContext}ã€‚æƒ…ç»ªç®¡ç†æŠ€å·§ï¼š<br>1. è¯†åˆ«å¹¶æ¥çº³å½“å‰æƒ…ç»ª<br>2. è®°å½•æƒ…ç»ªæ—¥è®°<br>3. ä¸ä¿¡ä»»çš„äººäº¤æµæ„Ÿå—<br>4. ä»äº‹å–œæ¬¢çš„æ´»åŠ¨è½¬ç§»æ³¨æ„åŠ›`,
                'æŠ‘éƒ': `${emotionContext}ã€‚å¦‚æœæŒç»­æƒ…ç»ªä½è½ï¼š<br>1. å¯»æ±‚ä¸“ä¸šå¿ƒç†å’¨è¯¢<br>2. ä¿æŒé€‚åº¦çš„ç¤¾äº¤æ´»åŠ¨<br>3. åšæŒé€‚é‡è¿åŠ¨<br>4. ç»™è‡ªå·±ä¸€äº›æ—¶é—´å’Œè€å¿ƒ`,
                'å­¦ä¹ ': `${emotionContext}ã€‚å­¦ä¹ å‹åŠ›ç®¡ç†ï¼š<br>1. åˆ¶å®šåˆç†çš„å­¦ä¹ è®¡åˆ’<br>2. ä½¿ç”¨ç•ªèŒ„å·¥ä½œæ³•æé«˜æ•ˆç‡<br>3. ä¿è¯å……è¶³çš„ä¼‘æ¯æ—¶é—´<br>4. ä¸åŒå­¦äº¤æµå­¦ä¹ å¿ƒå¾—`
            };
            
            const lowerInput = userInput.toLowerCase();
            for (const [keyword, response] of Object.entries(keywordResponses)) {
                if (lowerInput.includes(keyword)) {
                    return response;
                }
            }
            
            return `${emotionContext}ã€‚æˆ‘ç†è§£æ‚¨çš„å›°æ‰°ã€‚ä½œä¸ºå¿ƒç†åŠ©æ‰‹ï¼Œæˆ‘å»ºè®®æ‚¨å¯ä»¥æ›´è¯¦ç»†åœ°æè¿°å…·ä½“æƒ…å†µå’Œæ„Ÿå—ï¼Œè¿™æ ·æˆ‘èƒ½æä¾›æ›´æœ‰é’ˆå¯¹æ€§çš„å¸®åŠ©ã€‚`;
        }
        
        // æ·»åŠ åŠ è½½åŠ¨ç”»æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>